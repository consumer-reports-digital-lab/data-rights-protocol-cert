:PROPERTIES:
:ID:       20211116T134053.585822
:END:
#+title: DRP PIP Conformance Test Suite
#+filetags: :Project:Work:ConsumerReports:Development:Writing:
#+ARCOLOGY_KEY: doc/drp/conformance
#+OPTIONS: toc:nil num:nil

This is the working space for the [[id:1dbcc039-89bd-4177-b6e3-c818486d8060][Data Rights Protocol]] conformance test suite. Right now I'm developing it as an [[id:cce/literate_programming][Literate Programming]] document which feeds short snippets of code in to a BASH shell behind the scenes.

This work product is owned by the [[id:b1633d78-a920-40b7-8f71-9a7caa63cf5a][Consumer Reports Digital Lab]] until transferred in to a [[id:1dbcc039-89bd-4177-b6e3-c818486d8060][DRP]] governance organization.

* Introduction and Set Up

- First of all, follow the Introduction and Setup of the [[file:conformance-tools.org][Tools for the DRP Conformance Test Suite]] document and enter a =poetry shell=
- This assumes a UNIX-like environment. Developed on linux, mostly assumed to be compatible with macOS and WSL2, I will work with folks to debug issues.
- install bash, curl, and jq.
- All of the shell scripts can be copied in to a terminal, and any expected output is included below the commands, though rendering in GitHub or similar platforms may be confusing. [[id:20220305T172433.835616][But what is this org-mode document, why is this not a Markdown or HTML file?]]

* Test Plan
:PROPERTIES:
:ID:       20220209T171652.987733
:END:
:LOGBOOK:
CLOCK: [2021-12-29 Wed 11:20]--[2021-12-29 Wed 12:50] =>  1:30
:END:

#+PROPERTY: header-args:shell :session *drp-conformance* :results drawer

This thing uses bash, curl, jq, and a bit of python to run conformance validations.

Remember to be in a poetry shell!!

#+begin_src shell
poetry shell
#+end_src

#+results:
:results:
Spawning shell within /home/rrix/.cache/pypoetry/virtualenvs/datarightsprotocol-SSQrMXUl-py3.9
. /home/rrix/.cache/pypoetry/virtualenvs/datarightsprotocol-SSQrMXUl-py3.9/bin/activate
echo 'org_babel_sh_eoe'
(datarightsprotocol-SSQrMXUl-py3.9)
:end:

You'll want to change these maybe:

#+begin_src shell :results none -r
export BUSINESS_DOMAIN=example.com # (ref:1)
export DRP_TEST_CACHE=/tmp/drp-test/ # (ref:2)
export JWT_SECRET=my_jwts_are_secure # (ref:3)
#+end_src

The test suite will store response data and other "interstitial" data in the location specified in [[(2)]], this should be Good Enough on POSIX systems. The secret in [[(3)]] is used to sign the JWTs when =genjwts= is invoked. [[(1)]] is used in the Data Rights Discovery Endpoint tests.

** Data Rights Discovery Endpoint

Validating behavior of [[https://github.com/consumer-reports-digital-lab/data-rights-protocol#201-get-well-knowndata-rightsjson-data-rights-discovery-endpoint][Section 2.01]] of spec.

*** Covered Business's domain SHOULD have a =/.well-known/data-rights.json=

This =BUSINESS_DOMAIN= in [[(1)]] variable is used only in the Discovery Endpoint tests.

The intent of this test is to ensure that the PIPs which provide a =data-rights.json= well-known resource for their customers is providing one which exposes the URI. For a general PIP API validation which is not fronting a "real" Covered Business these tests can probably be omitted.

#+begin_src shell
curl -s $BUSINESS_DOMAIN/.well-known/data-rights.json \
     -o $DRP_TEST_CACHE/data-rights.json \
  || echo "NO GET: data-rights.json"

export DISCOVERY_FOUND=$(test -f $DRP_TEST_CACHE/data-rights.json)
export DISCOVERY_FILE=$DRP_TEST_CACHE/data-rights.json
#+end_src

*** Discovery Endpoint MUST Be Valid JSON

#+begin_src shell
jq . $DISCOVERY_FILE
#+end_src

#+results:
:results:
{
  "version": "0.4",
  "api_base": "https://example.com/data-rights",
  "actions": [
    "sale:opt-out",
    "sale:opt-in",
    "access",
    "deletion"
  ],
  "user_relationships": []
}
:end:

*** Discovery Endpoint MUST contain a version field

This Conformance Suite runs against version 0.4 of the protocol:

#+begin_src shell
[[ "$(jq -r .version $DISCOVERY_FILE)" = "0.4" ]] \
  || echo "NO VERSION: 0.4"
#+end_src

#+results:
:results:
:end:

*** Discovery Endpoint MUST provide an API base

#+begin_src shell
[[ -n "$(jq -r .api_base $DISCOVERY_FILE)" ]] \
  || echo "NO API_BASE"
export API_BASE=$(jq -r .api_base $DISCOVERY_FILE)
#+end_src

#+results:
:results:

:end:

*** Discovery Endpoint MUST provide a list of actions

#+begin_src shell
[[ ! "$(jq ".actions|length" $DISCOVERY_FILE)" = "0" ]] \
  || echo "NO ACTIONS"
export ACTIONS=$(jq -r ".actions|@sh" $DISCOVERY_FILE | tr -d \')
echo $ACTIONS
#+end_src

#+results:
:results:


sale:opt-out sale:opt-in access deletion
:end:

**** NEXT validate that these are all defined under [[https://github.com/consumer-reports-digital-lab/data-rights-protocol#301-supported-rights-actions][Supported Rights Actions]].

**** NEXT validate that these are all matching regexp =[0-9a-z:\-_]=

This isn't in the spec but it should be...

*** Discovery endpoint MAY contain a =user_relationships= hint set

#+begin_src shell
[[ ! "$(jq ".user_relationships|length" $DISCOVERY_FILE)" = "0" ]] \
  || echo "NO USER_RELATIONSHIPS"
#+end_src

#+results:
:results:

NO USER_RELATIONSHIPS
:end:

** NEXT OIDC flows

Most of the "is this valid OIDC?" will come through the openid conformance suite. What we need is a thing that can get a JWT signed by the Covered Business's =IDp=.

*** Discovery Endpoint references OIDC AS
*** OIDC Flow generates a JWT

Doing this in the shell is probably infeasible... little python client with a chromium embedded in it to do the full OIDC flow?

it'll be needed for assembling a DRR for OIDC-supporting CBs...

** Data Rights Requests
:PROPERTIES:
:ID:       20220110T161657.246138
:END:

*** Submitting Data Rights Requests using the [[id:20220124T185712.222187][Tools for the DRP Conformance Test Suite]]

- Requests are generated with the =genreqs= tool and optionally with =genjwts= to modify the bundled JWT.
- Requests are submitted with the included =swagger= server available by running =swagger= inside your poetry shell.
- Each test case will include a command to generate the request, and optionally you'll be able to modify it or the JWT token generation to match your needs.

*** Test Plan

**** Valid DRRs

For each valid DRR in that matrix:
- Submit the DRR
- Validate that the response is an [[https://github.com/consumer-reports-digital-lab/data-rights-protocol#303-schema-status-of-a-data-subject-exercise-request][Exercise Status]].
- Record the =request_id= in each
- Move request from =open= to an acknowledged =in_progress= state
- Validate that =status_callback=
- Validate that [[https://github.com/consumer-reports-digital-lab/data-rights-protocol#203-get-status-data-rights-status-endpoint][GET /status]] is an [[https://github.com/consumer-reports-digital-lab/data-rights-protocol#303-schema-status-of-a-data-subject-exercise-request][Exercise Status]].

This gets us to have a valid DRR inside of the PIP/CB's stack.

From there even some "valid" DRRs need to be exercised to test:
- revocation

**** Invalid DRRs

Some of these will be immediately rejected, but may also go in to =open= state for a while, this isn't well specified...

Generating/collecting these will be a pain in the ass...

**** NEXT Need User Verification testing

ughghghghgh

This will use a web browser, i guess...? This is where designing these test cases is going to suck the most.

The redirect URL is another thing for the little Heroku app? it's a "nice to have", mostly, though.

- Load =user_verification_url= in browser with some URL parameters attached
  - =request_id= associated with the test case
  - =identity= param w/ the JWT associated with the test case
  - =redirect_to= must be set to "something", not sure what...
    
**** NEXT All request states handed back by the API should be validated

- parse =received_at= to RFC 3339 string
- status is one of the valid states
- reason may exist

**** Specific validations for JWTs

- JWT should contain the identity claims
  - "verified" claims, v. verified claims
- JWT aud + sub
  - this depends on who issued the JWT:
    - AA-signed -> aud is the company, sub is the user's

*** Validating "end states" of valid DRRs

test case preflight:
- Submit a valid DRR
- Collect =request_id= from response status

**** Revocation

test cases:
- revoke immediately
- revoke in need_user_verification stage
- revoke while being processed =in_progress= by CB backend
  
**** NEXT Denied / Too Many Requests : Repeated requests with same identity token
**** Denied / No Match

- Submit a DRR with a signed-but-garbage token
- Collect DRS
- reason should be no_match

* Appendices

** 1: But what is this org-mode document, why is this not a Markdown or HTML file?
:PROPERTIES:
:ID:       20220305T172433.835616
:END:

The author of these documents thinks and develops software using a set of tools called [[https://www.gnu.org/software/emacs/][Emacs]] [[https://orgmode.org][Org Mode]]. It's an outlining and project planning tool with everything and the kitchen sink thrown in. When fully embraced, Emacs is a text and data editor which can be customized and automated to an incredible degree, and org-mode contains features and widely-used extensions which provide a similar level of meta-programming ability to documentation itself. It's also a quite convenient markup format to express things with more metadata and semantic structure than Markdown is capable of providing.

For all intents and purposes, however, this document should be usable in an HTML or PDF format as a static reference, and that is the intended deliverable format of it.

These documents use features that are basically built in, and an installation of anything newer than GNU Emacs 28 is probably going to work with minimal fussiness.

#+begin_src shell
emacs -l ob-shell conformance-tests.org --eval '(display-buffer (get-buffer-create "*drp-conformance*"))'=
#+end_src

If you execute this command and a GUI appears with this document, and an empty pane called =*drp-conformance*= at the bottom, then you can proceed to execute the commands *inside the document* by clicking in to the source blocks and pressing =Control-c= twice. The output will appear in the bottom pane, and the output will also be stored in the document.

While it's largely unreasonable to expect everyone to use a particular text editor, especially one with such anachronistic tendencies, it's perhaps interesting to think of this document itself as the first version of the DRP test-suite automation.
